'use strict';

var constants = require( './constants' );

var indexOf = require( './index-of' );

// Function::bind() polyfill.

var _bind = Function.prototype.bind || function bind ( c ) {
  var f = this;

  var a;

  if ( arguments.length <= 2 ) {
    return function bound () {
      return f.apply( c, arguments );
    };
  }

  a = Array.prototype.slice.call( arguments, 1 );

  return function bound () {
    return f.apply( c, a.concat( Array.prototype.slice.call( arguments ) ) );
  };
};

/**
 * @param {Array} p The partial arguments.
 * @param {Array} a The arguments.
 * @returns {Array} A processed arguments.
 */
function process ( p, a ) {
  var r = [];

  var j = -1;

  var i, l;

  for ( i = 0, l = p.length; i < l; ++i ) {
    if ( p[ i ] === constants.PLACEHOLDER ) {
      r.push( a[ ++j ] );
    } else {
      r.push( p[ i ] );
    }
  }

  for ( l = a.length; j < l; ++j ) {
    r.push( a[ i ] );
  }

  return r;
}

/**
 * @param {function} f The target function that should be bound.
 * @param {*} c The new context for the target function.
 * @param {...*} p The partial arguments, may contain constants.PLACEHOLDER.
 * @example
 *
 * function f ( x, y ) {
 *   return this[ x ] + this[ y ];
 * }
 *
 * const c = {
 *   x: 42,
 *   y: 1
 * };
 *
 * const bound = bind( f, c, constants.PLACEHOLDER, 'y' );
 *
 * bound( 'x' ); // -> 43
 */
module.exports = function bind ( f, c ) {
  var p;

  if ( typeof f !== 'function' ) {
    throw TypeError( constants.ERR.FUNCTION_EXPECTED );
  }

  // no partial arguments were provided

  if ( arguments.length <= 2 ) {
    return _bind.call( f, c );
  }

  p = Array.prototype.slice.call( arguments, 2 );

  // no placeholders in the partial arguments

  if ( indexOf( p, constants.PLACEHOLDER ) < 0 ) {
    return Function.prototype.call.apply( _bind, arguments );
  }

  return function bound () {
    return f.apply( c, process( p, arguments ) );
  };
};
