'use strict';

var closestNode = require( './closest-node' );
var DOMWrapper  = require( './DOMWrapper' );
var Event       = require( './Event' );

var events = {
  items: {},
  types: []
};

var support = typeof self !== 'undefined' && 'addEventListener' in self;

/**
 * @param {Node} element The element to which the listener should be attached.
 * @param {string} type The event type name.
 * @param {string?} selector The selector to which delegate an event.
 * @param {function} listener The event listener.
 * @param {boolean} useCapture
 * @param {boolean} [one] Remove the listener after it first dispatching?
 */

// on( document, 'click', '.post__like-button', ( event ) => {
//   const data = {
//     id: _( this ).parent( '.post' ).attr( 'data-id' )
//   }

//   ajax( '/like', { data } )
// }, false )

exports.on = function on ( element, type, selector, listener, useCapture, one ) {
  var item = {
    useCapture: useCapture,
    listener: listener,
    element: element,
    one: one
  };

  if ( selector ) {
    item.selector = selector;
  }

  if ( support ) {
    item.wrapper = function wrapper ( event, _element ) {
      if ( selector && ! _element && ! ( _element = closestNode( event.target, selector ) ) ) {
        return;
      }

      if ( one ) {
        exports.off( element, type, selector, listener, useCapture );
      }

      listener.call( _element || element, new Event( event ) );
    };

    element.addEventListener( type, item.wrapper, useCapture );
  } else if ( typeof listener === 'function' ) {
    item.wrapper = function wrapper ( event, _element ) {
      if ( selector && ! _element && ! ( _element = closestNode( event.target, selector ) ) ) {
        return;
      }

      if ( type === 'DOMContentLoaded' && element.readyState !== 'complete' ) {
        return;
      }

      if ( one ) {
        exports.off( element, type, selector, listener, useCapture );
      }

      listener.call( _element || element, new Event( event, type ) );
    };

    element.attachEvent( item.IEType = IEType( type ), item.wrapper );
  } else {
    throw TypeError( 'not implemented' );
  }

  if ( events.items[ type ] ) {
    events.items[ type ].push( item );
  } else {
    events.items[ type ] = [ item ];
    events.items[ type ].index = events.types.length;
    events.types.push( type );
  }
};

exports.off = function off ( element, type, selector, listener, useCapture ) {
  var i, items, item;

  if ( type == null ) {
    for ( i = events.types.length - 1; i >= 0; --i ) {
      event.off( element, events.types[ i ], selector );
    }

    return;
  }

  if ( ! ( items = events.items[ type ] ) ) {
    return;
  }

  for ( i = items.length - 1; i >= 0; --i ) {
    item = items[ i ];

    if ( item.element !== element ||
      listener != null && (
        item.listener !== listener ||
        item.useCapture !== useCapture ||
        item.selector && item.selector !== selector ) )
    {
      continue;
    }

    items.splice( i, 1 );

    if ( ! items.length ) {
      events.types.splice( items.index, 1 );
      events.items[ type ] = null;
    }

    if ( support ) {
      element.removeEventListener( type, item.wrapper, item.useCapture );
    } else {
      element.detachEvent( item.IEType, item.wrapper );
    }
  }
};

exports.trigger = function trigger ( element, type, data ) {
  var items = events.items[ type ];
  var i, closest, item;

  if ( ! items ) {
    return;
  }

  for ( i = 0; i < items.length; ++i ) {
    item = items[ i ];

    if ( element ) {
      closest = closestNode( element, item.selector || item.element );
    } else if ( item.selector ) {

      // jshint -W083

      new DOMWrapper( item.selector ).each( function () {
        item.wrapper( createEventWithTarget( type, data, this ), this );
      } );

      // jshint +W083

      continue;

    } else {
      closest = item.element;
    }

    if ( closest ) {
      item.wrapper( createEventWithTarget( type, data, element || closest ), closest );
    }
  }
};

exports.copy = function copy ( target, source, deep ) {
  var i, j, l, items, item, type;

  for ( i = events.types.length - 1; i >= 0; --i ) {

    if ( ( items = events.items[ type = events.types[ i ] ] ) ) {

      for ( j = 0, l = items.length; j < l; ++j ) {

        if ( ( item = items[ j ] ).target === source ) {
          event.on( target, type, null, item.listener, item.useCapture, item.one );
        }

      }

    }

  }

  if ( ! deep ) {
    return;
  }

  target = target.childNodes;
  source = source.childNodes;

  for ( i = target.length - 1; i >= 0; --i ) {
    event.copy( target[ i ], source[ i ], true );
  }
};

function createEventWithTarget ( type, data, target ) {

  var e = new Event( type, data );

  e.target = target;

  return e;

}

function IEType ( type ) {
  if ( type === 'DOMContentLoaded' ) {
    return 'onreadystatechange';
  }

  return 'on' + type;
}
